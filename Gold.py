# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ExVNWHTXCsCOUGq-Blo80MJaY085MtjQ

Importing Libraries
"""

import os
import pandas as pd
import numpy as np
import math
import datetime as dt
import matplotlib.pyplot as plt

from sklearn.metrics import mean_squared_error, mean_absolute_error, explained_variance_score, r2_score
from sklearn.metrics import mean_poisson_deviance, mean_gamma_deviance, accuracy_score
from sklearn.preprocessing import MinMaxScaler


import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.layers import LSTM


import matplotlib.pyplot as plt
from itertools import cycle
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

"""Dataset"""

maindf=pd.read_csv('/content/gold prices.csv')

"""Shape()"""

maindf.shape

"""head()"""

maindf.head()

"""tail()"""

maindf.tail()

"""info()"""

maindf.info()

"""describe()"""

maindf.describe()

"""Null Values Checks"""

print('Null Values Checks:',maindf.isnull().values.sum())

"""NA Values Checks"""

print('NA values:',maindf.isnull().values.any())

"""Shape

"""

maindf.shape

"""Analysis"""

sd=maindf.iloc[0][0]
ed=maindf.iloc[-1][0]

print('Starting Date',ed)
print('Ending Date',sd)

"""Gold price Analysis"""

maindf['Date'] = pd.to_datetime(maindf['Date'], format='%m/%d/%Y')

y_2013 = maindf.loc[(maindf['Date'] >= '08/11/2023')
                     & (maindf['Date'] < '08/17/2023')]

y_2013 = y_2013.drop(['Open','Volume'], axis=1)

monthvise= y_2013.groupby(y_2013['Date'].dt.strftime('%B'))[['High','Low']].mean()
new_order = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
             'September', 'October', 'November', 'December']
monthvise = monthvise.reindex(new_order, axis=0)
monthvise

fig = go.Figure()

fig.add_trace(go.Bar(
    x=monthvise.index,
    y=monthvise['High'],
    name='Gold High Price',
    marker_color='crimson'
))
fig.add_trace(go.Bar(
    x=monthvise.index,
    y=monthvise['Low'],
    name='Gold Low Price',
    marker_color='lightsalmon'
))

fig.update_layout(barmode='group', xaxis_tickangle=-45,
                  title='Monthwise comparision between Stock open and close price')
fig.show()

y_2013.groupby(y_2013['Date'].dt.strftime('%B'))['Low'].min()
monthvise_high = y_2013.groupby(maindf['Date'].dt.strftime('%B'))['High'].max()
monthvise_high = monthvise_high.reindex(new_order, axis=0)

monthvise_low = y_2013.groupby(y_2013['Date'].dt.strftime('%B'))['Low'].min()
monthvise_low = monthvise_low.reindex(new_order, axis=0)

fig = go.Figure()
fig.add_trace(go.Bar(
    x=monthvise_high.index,
    y=monthvise_high,
    name='Gold high Price',
    marker_color='rgb(0, 153, 204)'
))
fig.add_trace(go.Bar(
    x=monthvise_low.index,
    y=monthvise_low,
    name='Gold low Price',
    marker_color='rgb(255, 128, 0)'
))

fig.update_layout(barmode='group',
                  title=' Monthwise High and Low gold price')
fig.show()

names = cycle([ 'Gold High Price', 'Gold Low Price'])

fig = px.line(y_2013, x='Date', y=[y_2013['Low'], y_2013['High']],
              labels={'Date': 'Date', 'value': 'Gold value'})
fig.update_layout(title_text='Gold analysis chart', font_size=15, font_color='black', legend_title_text='Gold Parameters')
fig.for_each_trace(lambda t: t.update(name=next(names)))
fig.update_xaxes(showgrid=False)
fig.update_yaxes(showgrid=False)

fig.show()

"""Model Building"""

lowdf = maindf[['Date','Low']]
print("Shape of Low dataframe:", lowdf.shape)

fig = px.line(lowdf, x=lowdf.Date, y=lowdf.Low,labels={'date':'Date','low':'Low '})
fig.update_traces(marker_line_width=2, opacity=0.8, marker_line_color='orange')
fig.update_layout(title_text='Whole period of timeframe of Bitcoin close price 2014-2022', plot_bgcolor='white',
                  font_size=15, font_color='black')
fig.update_xaxes(showgrid=False)
fig.update_yaxes(showgrid=False)
fig.show()

"""1 year data"""

lowdf = lowdf[lowdf['Date'] > '2023-02-19']
low_gold = lowdf.copy()
print("Total data for prediction: ",lowdf.shape[0])

lowdf

fig = px.line(lowdf, x=lowdf.Date, y=lowdf.Low,labels={'date':'Date','low':'Low Stock'})
fig.update_traces(marker_line_width=2, opacity=0.8, marker_line_color='orange')
fig.update_layout(title_text='Considered period to predict Gold Lowq price',
                  plot_bgcolor='white', font_size=15, font_color='black')
fig.update_xaxes(showgrid=False)
fig.update_yaxes(showgrid=False)
fig.show()

del lowdf['Date']
scaler=MinMaxScaler(feature_range=(0,1))
lowdf=scaler.fit_transform(np.array(lowdf).reshape(-1,1))
print(lowdf.shape)

import pandas as pd

# Assuming lowdf is a NumPy array
lowdf = pd.DataFrame(lowdf)

training_size = int(len(lowdf) * 0.70)
test_size = len(lowdf) - training_size

train_data = lowdf.iloc[0:training_size, :]
test_data = lowdf.iloc[training_size:len(lowdf), :1]

print("train_data: ", train_data.shape)
print("test_data: ", test_data.shape)

def create_dataset(dataset, time_step=1):
    dataX, dataY = [], []
    for i in range(len(dataset)-time_step-1):
        a = dataset[i:(i+time_step), 0]   ###i=0, 0,1,2,3-----99   100
        dataX.append(a)
        dataY.append(dataset[i + time_step, 0])
    return np.array(dataX), np.array(dataY)

import numpy as np

def create_dataset(data, time_step=1):
    X, y = [], []
    for i in range(len(data)-time_step):
        X.append(data[i:(i+time_step), :])  # Assuming each row is a time step
        y.append(data[i + time_step, 0])    # Assuming the target variable is in the first column

    return np.array(X), np.array(y)

# Assuming train_data and test_data are DataFrames with the necessary structure
time_step = 15
X_train, y_train = create_dataset(train_data.values, time_step)
X_test, y_test = create_dataset(test_data.values, time_step)

print("X_train: ", X_train.shape)
print("y_train: ", y_train.shape)
print("X_test: ", X_test.shape)
print("y_test", y_test.shape)

# reshape input to be [samples, time steps, features] which is required for LSTM
X_train =X_train.reshape(X_train.shape[0],X_train.shape[1] , 1)
X_test = X_test.reshape(X_test.shape[0],X_test.shape[1] , 1)

print("X_train: ", X_train.shape)
print("X_test: ", X_test.shape)

"""Model Building"""

model=Sequential()

model.add(LSTM(10,input_shape=(None,1),activation="relu"))

model.add(Dense(1))

model.compile(loss="mean_squared_error",optimizer="adam")

history = model.fit(X_train,y_train,validation_data=(X_test,y_test),epochs=200,batch_size=32,verbose=1)

"""Losses : Plotting Loss vs Validation loss"""

import matplotlib.pyplot as plt

loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(len(loss))

plt.plot(epochs, loss, 'r', label='Training loss')
plt.plot(epochs, val_loss, 'b', label='Validation loss')
plt.title('Training and validation loss')
plt.legend(loc=0)
plt.figure()


plt.show()

train_predict=model.predict(X_train)
test_predict=model.predict(X_test)
train_predict.shape, test_predict.shape

""" Evaluation of Model"""

train_predict = scaler.inverse_transform(train_predict)
test_predict = scaler.inverse_transform(test_predict)
original_ytrain = scaler.inverse_transform(y_train.reshape(-1,1))
original_ytest = scaler.inverse_transform(y_test.reshape(-1,1))

# Evaluation metrices RMSE and MAE
print("Train data RMSE: ", math.sqrt(mean_squared_error(original_ytrain,train_predict)))
print("Train data MSE: ", mean_squared_error(original_ytrain,train_predict))
print("Train data MAE: ", mean_absolute_error(original_ytrain,train_predict))
print("-------------------------------------------------------------------------------------")
print("Test data RMSE: ", math.sqrt(mean_squared_error(original_ytest,test_predict)))
print("Test data MSE: ", mean_squared_error(original_ytest,test_predict))
print("Test data MAE: ", mean_absolute_error(original_ytest,test_predict))

"""**Variance Regression Score**"""

print("Train data explained variance regression score:",
      explained_variance_score(original_ytrain, train_predict))
print("Test data explained variance regression score:",
      explained_variance_score(original_ytest, test_predict))

## R square score for regression
print("Train data R2 score:", r2_score(original_ytrain, train_predict))
print("Test data R2 score:", r2_score(original_ytest, test_predict))

## Regression Loss Mean Gamma deviance regression loss (MGD) and Mean Poisson deviance regression loss (MPD)
print("Train data MGD: ", mean_gamma_deviance(original_ytrain, train_predict))
print("Test data MGD: ", mean_gamma_deviance(original_ytest, test_predict))
print("----------------------------------------------------------------------")
print("Train data MPD: ", mean_poisson_deviance(original_ytrain, train_predict))
print("Test data MPD: ", mean_poisson_deviance(original_ytest, test_predict))

# Importing libraries
import numpy as np
import matplotlib.pyplot as plt

# Predicting on the test data
y_pred = model.predict(X_test)

# Inverting the scaling transformation to get original values
y_pred = scaler.inverse_transform(y_pred.reshape(-1, 1))
y_test_original = scaler.inverse_transform(np.array(y_test).reshape(-1, 1))

# Plotting the original and predicted low prices
plt.figure(figsize=(16, 8))
plt.plot(y_test_original, label='Original Low Price', color='blue')
plt.plot(y_pred, label='Predicted Low Price', color='red')
plt.title('Gold Low Price Prediction using LSTM')
plt.xlabel('Time (days)')
plt.ylabel('Low Price')
plt.legend()
plt.show()

# Extract the closing prices
close_prices = gold_data["Low"].values

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_prices = scaler.fit_transform(close_prices.reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_prices) * 0.8)
test_size = len(scaled_prices) - train_size
train_data, test_data = scaled_prices[0:train_size, :], scaled_prices[train_size:len(scaled_prices), :]

# Create the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(train_data.shape[1], 1)))
model.add(LSTM(50))
model.add(Dense(1))

model.compile(loss="mean_squared_error", optimizer="adam")

# Train the model
model.fit(train_data, train_data, epochs=10, batch_size=32)

# Make predictions for the next 30 days
inputs = test_data[len(test_data) - 30:, :]
predictions = model.predict(inputs)

# Inverse transform the predictions
predicted_prices = scaler.inverse_transform(predictions)

# Print the predicted prices
for i in range(len(predicted_prices)):
  print(f"Predicted price on day {i+1}: {predicted_prices[i][0]:.2f}")

# Extract the closing prices
close_prices = gold_data["Low"].values

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_prices = scaler.fit_transform(close_prices.reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_prices) * 0.8)
test_size = len(scaled_prices) - train_size
train_data, test_data = scaled_prices[0:train_size, :], scaled_prices[train_size:len(scaled_prices), :]

# Create the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(train_data.shape[1], 1)))
model.add(LSTM(50))
model.add(Dense(1))

model.compile(loss="mean_squared_error", optimizer="adam")

# Train the model
model.fit(train_data, train_data, epochs=10, batch_size=32)

# Make predictions for the next 15 days
inputs = test_data[len(test_data) - 15:, :]
predictions = model.predict(inputs)

# Inverse transform the predictions
predicted_prices = scaler.inverse_transform(predictions)

# Print the predicted prices
for i in range(len(predicted_prices)):
  print(f"Predicted price on day {i+1}: {predicted_prices[i][0]:.2f}")

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_prices = scaler.fit_transform(close_prices.reshape(-1, 1))

# Split the data into training and testing sets
train_size = int(len(scaled_prices) * 0.8)
test_size = len(scaled_prices) - train_size
train_data, test_data = scaled_prices[0:train_size, :], scaled_prices[train_size:len(scaled_prices), :]

# Create the LSTM model
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(train_data.shape[1], 1)))
model.add(LSTM(50))
model.add(Dense(1))

model.compile(loss="mean_squared_error", optimizer="adam")

# Train the model
model.fit(train_data, train_data, epochs=10, batch_size=32)

# Make predictions for the last 15 days
inputs_last_15_days = test_data[len(test_data) - 15:, :]
predictions_last_15_days = model.predict(inputs_last_15_days)

# Make predictions for the next 30 days
inputs_next_30_days = test_data[len(test_data) - 30:, :]
predictions_next_30_days = model.predict(inputs_next_30_days)

# Inverse transform the predictions
predicted_prices_last_15_days = scaler.inverse_transform(predictions_last_15_days)
predicted_prices_next_30_days = scaler.inverse_transform(predictions_next_30_days)

# Plotting the last 15 days' predictions
last_15_days_actual = scaler.inverse_transform(test_data[len(test_data) - 15:, :])
last_days = np.arange(len(last_15_days_actual))

plt.plot(last_days, last_15_days_actual, label='Last 15 Days (Actual)', marker='o', linestyle='-', color='blue')
plt.plot(last_days, predicted_prices_last_15_days, label='Last 15 Days (Predicted)', marker='o', linestyle='--', color='orange')

# Adding labels and title
plt.xlabel('Days')
plt.ylabel('Gold Prices')
plt.title('Comparison of Last 15 Days Actual and Predicted Gold Prices')
plt.legend()
plt.show()

# Plotting the next 30 days' predictions
day_pred = np.arange(len(last_15_days_actual), len(last_15_days_actual) + len(predicted_prices_next_30_days))
plt.plot(day_pred, predicted_prices_next_30_days, label='Next 30 Days (Predicted)', marker='o', linestyle='--', color='green')

# Adding labels and title
plt.xlabel('Days')
plt.ylabel('Gold Prices')
plt.title('Predicted Gold Prices for the Next 30 Days')
plt.legend()
plt.show()